#!/usr/bin/env python3
"""
Copyright 2018 Pedro Santos <pedrosans@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

import time, gc
import numpy as np
from bio.parameters99ff import Parameters
from bio.pdb import Molecule
from bio.molecular_dynamics import ForceField
from inf.optimization import GradientDescent, Pso


class Docking:

	def __init__(self, complex=None, ligand=None, receptor=None):
		self.complex = complex
		self.ligand = ligand
		starting_point = np.array([11.102, 24.461, 1.386])
		starting_point += np.array([7.5]*3)
		current_point = self.ligand.atoms[30].point
		delta_to_starting_point = current_point - starting_point

		self.ligand.translate(delta_to_starting_point)
		self.ligand.reset_starting_point()

		self.receptor = receptor
		self.parameters = Parameters()
		self.complex.set_force_field_parameters(self.parameters)
		self.ligand.set_force_field_parameters(self.parameters)
		self.receptor.set_force_field_parameters(self.parameters)

		self.force_field = ForceField(self.parameters)
		self.force_field.calculate_energy(self.receptor.get_topology())
		self.force_field.print_energy()
		self.receptor_energy = self.force_field.energy

		self.force_field.calculate_energy(self.ligand.get_topology(), test_electrostatic_only=True)
		self.force_field.print_energy()
		self.ligand_energy = self.force_field.energy

		self.complex_topology = self.receptor.get_topology()
		self.complex_topology.add_participant(self.ligand.get_topology())
		self.force_field.calculate_energy(self.complex_topology)
		self.force_field.print_energy()
		self.complex_energy = self.force_field.energy
		self.docking_energy = self.complex_energy - self.ligand_energy - self.receptor_energy

		print('Ligand energy: {:10.3f}'.format(self.ligand_energy))
		print('Receptor energy: {:10.3f}'.format(self.receptor_energy))
		print('Complex energy: {:10.3f}'.format(self.complex_energy))
		print('Docking energy: {:10.3f}'.format(self.docking_energy))

		self.pso = Pso(self.complex_energy_function)
		self.pso.set_bounds(-180, 180)
		self.pso.dimensions_number = 3
		self.pso.number_of_particles = 8
		self.pso.iterations = 3
		self.pso.personal_best_retention = 0.003
		self.pso.global_best_retention = 0.03
		self.pso.inertia = 1

	def complex_energy_function(self, particle):
		a = self.atoms[self.atom_index]
		a.translate(particle.position)
		return self.force_field.calculate_energy(self.molecule)

	def apply_particle(self, particle):
		self.ligand.translate_starting_point(particle.dimensions)

	def run(self):
		optimization = self.pso
		optimization.run()
		self.apply_particle(optimization.best_particle)
		self.force_field.calculate_energy(self.molecule.get_topology())
		self.force_field.print_energy()
		import sys
		if len(sys.argv) > 1:
			m.write('/home/pedro/tmp', 'best-' + sys.argv[1] + '.pdb')
		else:
			m.write('/home/pedro/tmp', 'best.pdb')


m_cristal = Molecule(pdb_file_location='/home/pedro/tmp/docking/cristal.pdb')
m_ligante = Molecule(pdb_file_location='/home/pedro/tmp/docking/ligante.pdb')
m_receptor = Molecule(pdb_file_location='/home/pedro/tmp/docking/receptor.pdb')

docking = Docking(complex=m_cristal, ligand=m_ligante, receptor=m_receptor)
start_time = time.time()
# docking.run()
print("\t\t\t\t\t\t\t\t\t\t\tDocking function executed in: %s seconds" % (time.time() - start_time))
